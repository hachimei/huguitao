<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <title>地形开挖</title>
    <link href="../static/Cesium/Widgets/widgets.css" rel="stylesheet" />
    <script src="../static/Cesium/Cesium.js"></script>
    <script src="../static/plugin/TerrainClipPlan.js"></script>
    <style>
        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .tools {
            position: absolute;
            top: 20px;
            left: 12px;
            z-index: 10;
        }
    </style>

</head>

<body>
    <div class="tools">
        <button onclick="terrainClip(true)">地形开挖</button>
        <button onclick="heightChange(~~(Math.random() * 300))">改变高度</button>
    </div>
    <div id="cesiumContainer"></div>
    <script>

        const Cesium = window.Cesium;
        /**
         * 创建贴地多边形
         * @param {object} viewer viewer
         * @param {Array} resultList
         * @param {{id:String,color:object,outlineColor:object,outlineWidth:number}} options {id，填充颜色，轮廓线颜色，轮廓线宽度}
         * @param {Function} callback 携带创建的多边形对象
         */
        const CreatePolygonOnGround = function (viewer, resultList, options, callback) {
            if (!viewer) throw new Error("no viewer object!");
            options = options || {};
            let id = options.id || setSessionid(); //Polygon的id
            if (viewer.entities.getById(id))
                throw new Error("the id parameter is an unique value");
            let color = options.color || Cesium.Color.RED; //Polygon的填充色
            let outlineColor = options.outlineColor || color.withAlpha(1); //Polygon的轮廓线颜色
            let outlineWidth = options.outlineWidth || 2; //Polygon的轮廓线宽度
            const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
            let toolTip = "左键点击开始绘制";
            let anchorpoints = [];
            let polygon = undefined;
            let drawStatus = true;
            handler.setInputAction(function (event) {
                let pixPos = event.position;
                let cartesian = getCatesian3FromPX(viewer, pixPos);
                if (anchorpoints.length == 0) {
                    toolTip = "左键添加第二个点";
                    anchorpoints.push(cartesian);
                    let linePoints = new Cesium.CallbackProperty(function () {
                        let verPoints = anchorpoints.concat([anchorpoints[0]]);
                        return verPoints;
                    }, false);
                    let dynamicPositions = new Cesium.CallbackProperty(function () {
                        return new Cesium.PolygonHierarchy(anchorpoints);
                    }, false);
                    polygon = viewer.entities.add({
                        name: "Polygon",
                        id: id,
                        polyline: {
                            positions: linePoints,
                            width: outlineWidth,
                            material: outlineColor,
                            clampToGround: true,
                        },
                        polygon: {
                            heightReference: Cesium.HeightReference.None,
                            hierarchy: dynamicPositions,
                            material: color,
                        },
                    });
                    polygon.GeoType = "Polygon";
                } else {
                    toolTip = "左键添加点，Ctrl+Z回退，右键完成绘制";
                }
                anchorpoints.push(cartesian);
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
            handler.setInputAction(function (movement) {
                let endPos = movement.endPosition;
                // CreateRemindertip(toolTip, endPos, true);
                if (Cesium.defined(polygon)) {
                    anchorpoints.pop();
                    let cartesian = getCatesian3FromPX(viewer, endPos);
                    anchorpoints.push(cartesian);
                }
                if (anchorpoints.length === 3) {
                    polygon.polygon.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                }
            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            handler.setInputAction(function (event) {
                anchorpoints.pop();
                polygon.pottingPoint = anchorpoints;
                resultList.push(polygon);
                handler.destroy();
                // CreateRemindertip(toolTip, event.position, false);
                drawStatus = false;
                if (typeof callback == "function") callback(polygon);
            }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);
            //Ctrl + Z回退
            document.onkeydown = function (event) {
                if (event.ctrlKey && window.event.keyCode == 90) {
                    if (!drawStatus) {
                        return false;
                    }
                    anchorpoints.pop();
                    if (anchorpoints.length == 2) {
                        toolTip = "左键添加第二个点";
                    }
                }
            };
        };
        function getCatesian3FromPX(viewer, px) {
            let picks = viewer.scene.drillPick(px);
            let cartesian = null;
            let isOn3dtiles = false,
                isOnTerrain = false;
            // drillPick
            for (let i in picks) {
                let pick = picks[i];
                if (
                    (pick && pick.primitive instanceof Cesium.Cesium3DTileFeature) ||
                    (pick && pick.primitive instanceof Cesium.Cesium3DTileset) ||
                    (pick && pick.primitive instanceof Cesium.Model)
                ) {
                    //模型上拾取
                    isOn3dtiles = true;
                }
                // 3dtilset
                if (isOn3dtiles) {
                    viewer.scene.pick(px);
                    cartesian = viewer.scene.pickPosition(px);
                    if (cartesian) {
                        let cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                        if (cartographic.height < 0) cartographic.height = 0;
                        let lon = Cesium.Math.toDegrees(cartographic.longitude),
                            lat = Cesium.Math.toDegrees(cartographic.latitude),
                            height = cartographic.height;
                        cartesian = transformWGS84ToCartesian(viewer, {
                            lng: lon,
                            lat: lat,
                            alt: height,
                        });
                    }
                }
            }
            // 地形
            let boolTerrain =
                viewer.terrainProvider instanceof Cesium.EllipsoidTerrainProvider;
            // Terrain
            if (!isOn3dtiles && !boolTerrain) {
                let ray = viewer.scene.camera.getPickRay(px);
                if (!ray) return null;
                cartesian = viewer.scene.globe.pick(ray, viewer.scene);
                isOnTerrain = true;
            }
            // 地球
            if (!isOn3dtiles && !isOnTerrain && boolTerrain) {
                cartesian = viewer.scene.camera.pickEllipsoid(
                    px,
                    viewer.scene.globe.ellipsoid
                );
            }
            if (cartesian) {
                let position = transformCartesianToWGS84(viewer, cartesian);
                if (position.alt < 0) {
                    cartesian = transformWGS84ToCartesian(viewer, position, 0.1);
                }
                return cartesian;
            }
            return false;
        }

        /***
         * 坐标转换 84转笛卡尔
         * @param {Object} {lng,lat,alt} 地理坐标
         * @return {Object} Cartesian3 三维位置坐标
         */
        function transformWGS84ToCartesian(viewer, position, alt) {
            return position
                ? Cesium.Cartesian3.fromDegrees(
                    position.lng || position.lon,
                    position.lat,
                    (position.alt = alt || position.alt),
                    Cesium.Ellipsoid.WGS84
                )
                : Cesium.Cartesian3.ZERO;
        }

        /***
         * 坐标转换 笛卡尔转84
         * @param {Object} Cartesian3 三维位置坐标
         * @return {Object} {lng,lat,alt} 地理坐标
         */
        function transformCartesianToWGS84(viewer, cartesian) {
            let ellipsoid = Cesium.Ellipsoid.WGS84;
            let cartographic = ellipsoid.cartesianToCartographic(cartesian);
            return {
                lng: Cesium.Math.toDegrees(cartographic.longitude),
                lat: Cesium.Math.toDegrees(cartographic.latitude),
                alt: cartographic.height,
            };
        }
        function setSessionid(num) {
            let len = num || 32;
            let chars = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678";
            let maxPos = chars.length;
            let pwd = "";
            for (let i = 0; i < len; i++) {
                pwd += chars.charAt(Math.floor(Math.random() * maxPos));
            }
            return pwd;
        }

        //地形开挖

        class TerrainExcavation {
            constructor(viewer, options) {
                if (!viewer) throw new Error("no viewer object!");
                this.viewer = viewer;
                this.options = options || {};
                this._height = this.options.height || 0;
                this.bottomImg = options.bottomImg;
                this.wallImg = options.wallImg;
                this.splitNum = Cesium.defaultValue(options.splitNum, 50);
                this.init();
            }
            init() {
                Object.defineProperties(TerrainExcavation.prototype, {
                    show: {
                        get: function () {
                            return this._show;
                        },
                        set: function (e) {
                            this._show = e;
                            this.switchExcavate(e);
                        },
                    },
                    height: {
                        get: function () {
                            return this._height;
                        },
                        set: function (e) {
                            this._height = e;
                            this.updateExcavateDepth(e);
                        },
                    },
                });
            }
            startCreate() {
                const $this = this;
                CreatePolygonOnGround(
                    $this.viewer,
                    [],
                    {
                        color: Cesium.Color.RED.withAlpha(0.1),
                        outlineColor: Cesium.Color.YELLOW,
                        outlineWidth: 2,
                    },
                    function (polygon) {
                        console.log(polygon);
                        const points = polygon.pottingPoint;
                        $this.viewer.entities.remove(polygon);
                        $this.updateData(points);
                    }
                );
                return;
            }
            updateData(activePoints) {
                let viewer = this.viewer;
                this.clear();
                let clippingPlanesList = [];
                let car3Difference = Cesium.Cartesian3.subtract(
                    activePoints[0],
                    activePoints[1],
                    new Cesium.Cartesian3()
                ); //计算两个笛卡尔函数的分量差异
                let boolDiff = car3Difference.x > 0;
                this.excavateMinHeight = 9999;
                for (let index = 0; index < activePoints.length; ++index) {
                    let s = (index + 1) % activePoints.length;
                    let curMidPoint = Cesium.Cartesian3.midpoint(
                        activePoints[index],
                        activePoints[s],
                        new Cesium.Cartesian3()
                    );
                    let cartographic = Cesium.Cartographic.fromCartesian(activePoints[index]);
                    let curHeight =
                        viewer.scene.globe.getHeight(cartographic) || cartographic.height;
                    console.log(curHeight);
                    if (curHeight < this.excavateMinHeight) {
                        this.excavateMinHeight = curHeight;
                    }
                    let curMidPointNormal = Cesium.Cartesian3.normalize(
                        curMidPoint,
                        new Cesium.Cartesian3()
                    );
                    let curMidPointDifference = boolDiff
                        ? Cesium.Cartesian3.subtract(
                            activePoints[index],
                            curMidPoint,
                            new Cesium.Cartesian3()
                        )
                        : Cesium.Cartesian3.subtract(
                            activePoints[s],
                            curMidPoint,
                            new Cesium.Cartesian3()
                        );
                    curMidPointDifference = Cesium.Cartesian3.normalize(
                        curMidPointDifference,
                        curMidPointDifference
                    );
                    let curMidPointCross = Cesium.Cartesian3.cross(
                        curMidPointDifference,
                        curMidPointNormal,
                        new Cesium.Cartesian3()
                    );
                    curMidPointCross = Cesium.Cartesian3.normalize(
                        curMidPointCross,
                        curMidPointCross
                    );
                    let plane = new Cesium.Plane(curMidPointCross, 0);
                    let distance = Cesium.Plane.getPointDistance(plane, curMidPoint);
                    clippingPlanesList.push(
                        new Cesium.ClippingPlane(curMidPointCross, distance)
                    );
                }
                this.viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection(
                    {
                        planes: clippingPlanesList,
                        edgeWidth: 1,
                        edgeColor: Cesium.Color.WHITE,
                        enabled: true,
                    }
                );
                this.prepareWell(activePoints);
                this.createWell(this.wellData);
                this.viewer.entities.remove(this.drawGeomtry);
            }

            clear() {
                if (this.viewer.scene.globe.clippingPlanes) {
                    this.viewer.scene.globe.clippingPlanes.removeAll();
                    this.viewer.scene.primitives.remove(this.bottomSurface);
                    this.viewer.scene.primitives.remove(this.wellWall);
                    this.viewer.scene.render();
                }
            }
            //计算并更新wellData
            prepareWell(activePoints) {
                let pointLength = activePoints.length;
                let heightDiff = this.excavateMinHeight - this.height;
                let no_height_top = [],
                    bottom_pos = [],
                    lerp_pos = [];
                for (let l = 0; l < pointLength; l++) {
                    let u = l == pointLength - 1 ? 0 : l + 1;
                    let point0 = [
                        Cesium.Cartographic.fromCartesian(activePoints[l]).longitude,
                        Cesium.Cartographic.fromCartesian(activePoints[l]).latitude,
                    ];
                    let point1 = [
                        Cesium.Cartographic.fromCartesian(activePoints[u]).longitude,
                        Cesium.Cartographic.fromCartesian(activePoints[u]).latitude,
                    ];
                    if (0 == l) {
                        lerp_pos.push(new Cesium.Cartographic(point0[0], point0[1]));
                        bottom_pos.push(
                            Cesium.Cartesian3.fromRadians(point0[0], point0[1], heightDiff)
                        );
                        no_height_top.push(
                            Cesium.Cartesian3.fromRadians(point0[0], point0[1], 0)
                        );
                    }
                    for (let p = 1; p <= this.splitNum; p++) {
                        let m = Cesium.Math.lerp(point0[0], point1[0], p / this.splitNum);
                        let g = Cesium.Math.lerp(point0[1], point1[1], p / this.splitNum);
                        (l == pointLength - 1 && p == this.splitNum) ||
                            (lerp_pos.push(new Cesium.Cartographic(m, g)),
                                bottom_pos.push(Cesium.Cartesian3.fromRadians(m, g, heightDiff)),
                                no_height_top.push(Cesium.Cartesian3.fromRadians(m, g, 0)));
                    }
                }
                this.wellData = {
                    lerp_pos: lerp_pos,
                    bottom_pos: bottom_pos,
                    no_height_top: no_height_top,
                };
            }
            //开始创建底面和侧面
            createWell(wallData) {
                let $this = this;
                if (this.viewer.terrainProvider._layers) {
                    this.createBottomSurface(wallData.bottom_pos);
                    let positions = Cesium.sampleTerrainMostDetailed(
                        this.viewer.terrainProvider,
                        wallData.lerp_pos
                    );
                    Cesium.when(positions, function (pos) {
                        let positionList = [];
                        for (let index = 0; index < pos.length; index++) {
                            const element = pos[index];
                            let curPos = Cesium.Cartesian3.fromRadians(
                                element.longitude,
                                element.latitude,
                                element.height
                            );
                            positionList.push(curPos);
                        }
                        $this.createWellWall(wallData.bottom_pos, positionList);
                    });
                } else {
                    this.createBottomSurface(wallData.bottom_pos);
                    this.createWellWall(wallData.bottom_pos, wallData.no_height_top);
                }
            }
            //坐标转换，转出经纬度格式
            ellipsoidToDegree(pos) {
                let cartesian3 = new Cesium.Cartesian3(pos.x, pos.y, pos.z);
                let cartographic =
                    this.viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian3);
                return {
                    longitude: Cesium.Math.toDegrees(cartographic.longitude),
                    latitude: Cesium.Math.toDegrees(cartographic.latitude),
                    altitude: cartographic.height,
                };
            }
            //创建地形开挖的底面对象
            createBottomSurface(points) {
                if (points.length) {
                    let minHeight = this.getMinHeight(points);
                    let positions = [];
                    for (let i = 0; i < points.length; i++) {
                        let curPoint = this.ellipsoidToDegree(points[i]);
                        positions.push(curPoint.longitude, curPoint.latitude, minHeight);
                    }
                    let polygon = new Cesium.PolygonGeometry({
                        polygonHierarchy: new Cesium.PolygonHierarchy(
                            Cesium.Cartesian3.fromDegreesArrayHeights(positions)
                        ),
                        perPositionHeight: true,
                    });

                    let material = new Cesium.Material({
                        fabric: {
                            type: "Image",
                            uniforms: {
                                image: this.bottomImg,
                            },
                        },
                    });
                    let appearance = new Cesium.MaterialAppearance({
                        translucent: false,
                        flat: true,
                        material: material,
                    });
                    this.bottomSurface = new Cesium.Primitive({
                        geometryInstances: new Cesium.GeometryInstance({
                            geometry: Cesium.PolygonGeometry.createGeometry(polygon),
                        }),
                        appearance: appearance,
                        asynchronous: false,
                    });
                    this.viewer.scene.primitives.add(this.bottomSurface);
                }
            }
            // 创建地形开挖的侧面墙对象
            createWellWall(bottomPos, positionList) {
                let minHeight = this.getMinHeight(bottomPos);
                let maxHeights = [],
                    minHeights = [];
                for (let i = 0; i < positionList.length; i++) {
                    maxHeights.push(this.ellipsoidToDegree(positionList[i]).altitude);
                    minHeights.push(minHeight);
                }
                let wall = new Cesium.WallGeometry({
                    positions: positionList,
                    maximumHeights: maxHeights,
                    minimumHeights: minHeights,
                });
                let geometry = Cesium.WallGeometry.createGeometry(wall);
                let material = new Cesium.Material({
                    fabric: {
                        type: "Image",
                        uniforms: {
                            image: this.wallImg,
                        },
                    },
                });
                let appearance = new Cesium.MaterialAppearance({
                    translucent: false,
                    flat: true,
                    material: material,
                });
                this.wellWall = new Cesium.Primitive({
                    geometryInstances: new Cesium.GeometryInstance({
                        geometry: geometry,
                        attributes: {
                            color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                                Cesium.Color.GREY
                            ),
                        },
                        id: "PitWall",
                    }),
                    appearance: appearance,
                    asynchronous: false,
                });
                this.viewer.scene.primitives.add(this.wellWall);
            }
            //获取地形开挖最低点高程值
            getMinHeight(points) {
                let minHeight = 5000000;
                let minPoint = null;
                for (let i = 0; i < points.length; i++) {
                    let height = points[i]["z"];
                    if (height < minHeight) {
                        minHeight = height;
                        minPoint = this.ellipsoidToDegree(points[i]);
                    }
                }
                return minPoint.altitude;
            }
            switchExcavate(show) {
                if (show) {
                    this.viewer.scene.globe.material = null;
                    this.wellWall.show = true;
                    this.bottomSurface.show = true;
                } else {
                    this.viewer.scene.globe.material = null;
                    this.wellWall.show = false;
                    this.bottomSurface.show = false;
                }
            }

            updateExcavateDepth(height) {
                this.viewer.scene.primitives.remove(this.bottomSurface);
                this.viewer.scene.primitives.remove(this.wellWall);
                console.log(this.wellData, this.excavateMinHeight);
                let lerp_pos = this.wellData.lerp_pos;
                let posList = [];
                for (let n = 0; n < lerp_pos.length; n++) {
                    posList.push(
                        Cesium.Cartesian3.fromRadians(
                            lerp_pos[n].longitude,
                            lerp_pos[n].latitude,
                            this.excavateMinHeight - height
                        )
                    );
                }
                this.wellData.bottom_pos = posList;
                this.createWell(this.wellData);
            }
        }

        var viewer = undefined;
        var terrainClipPlanObj = undefined;
        var height = 200;

        let key = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxZjI0ZWRkMi1iYjUzLTRlZGYtYjk4Yy0yNTczYzY0YWY1NjgiLCJpZCI6MTY3ODYsImlhdCI6MTY3ODE1NTIyMX0.x0jWIoh2wIH21yx5LCfUnx_kN6Zh6f7zagedKFc1PRw";
        Cesium.Ion.defaultAccessToken = key;

        viewer = viewer = new Cesium.Viewer("cesiumContainer", {
            imageryProvider: new Cesium.ArcGisMapServerImageryProvider({
                url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",
            }),
            terrainProvider: Cesium.createWorldTerrain(),
            geocoder: true,
            homeButton: true,
            sceneModePicker: true,
            baseLayerPicker: true,
            navigationHelpButton: true,
            animation: true,
            timeline: true,
            fullscreenButton: true,
            vrButton: true,
            //关闭点选出现的提示框
            selectionIndicator: false,
            infoBox: false,
        });
        viewer._cesiumWidget._creditContainer.style.display = "none"; // 隐藏版权
        initCamera();

        function heightChange(val) {
            if (terrainClipPlanObj) {
                terrainClipPlanObj.height = val;
            }
        }
        function terrainClip(bool) {
            if (!terrainClipPlanObj) {
                terrainClipPlanObj = new TerrainExcavation(viewer, {
                    height: height,
                    splitNum: 1000,
                    bottomImg: "../static/images/excavate_bottom_min.jpg",
                    wallImg: "../static/images/excavate_side_min.jpg",
                });
            }
            if (bool) {
                console.log("开始地形开挖");
                terrainClipPlanObj.startCreate();
            } else {
                console.log("结束地形开挖");
                terrainClipPlanObj.clear();
            }
        }
        function initCamera() {
            viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(110, 40, 10000.0),
                orientation: {
                    heading: 0.09085393067733083,
                    pitch: -1.5329743385768886,
                    roll: 0.0,
                },
                duration: 3,
            });
        }
        function getLocation() {
            let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
            handler.setInputAction(function (event) {
                let earthPosition = viewer.scene.pickPosition(event.position);
                if (Cesium.defined(earthPosition)) {
                    let cartographic = Cesium.Cartographic.fromCartesian(earthPosition);
                    let lon = Cesium.Math.toDegrees(cartographic.longitude).toFixed(5);
                    let lat = Cesium.Math.toDegrees(cartographic.latitude).toFixed(5);
                    let height = cartographic.height.toFixed(2);
                    console.log(earthPosition, {
                        lon: lon,
                        lat: lat,
                        height: height,
                    });
                }
            }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }


    </script>
</body>

</html>